<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Match TSV Generator (BO + TB)</title>
<style>
  :root{--bg:#f7f8fb;--pane:#fff;--muted:#666}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:18px;background:var(--bg);color:#111}
  h2{margin:0 0 6px}
  .wrap{display:flex;gap:18px;align-items:flex-start}
  .pane{flex:1;background:var(--pane);border:1px solid #e7eaf3;padding:12px;border-radius:8px;min-width:260px;box-shadow:0 1px 6px rgba(10,20,40,0.04)}
  textarea{width:100%;min-height:300px;font-family:monospace;padding:10px;border-radius:6px;border:1px solid #ddd}
  .divider{width:2px;background:linear-gradient(#e6e9f2,#e6e9f2);border-radius:2px;align-self:stretch}
  .controls{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{display:inline-flex;gap:6px;align-items:center}
  input[type=number]{width:72px;padding:6px;border-radius:6px;border:1px solid #ccc}
  input[type=checkbox]{transform:scale(1.05)}
  button{background:#1f6feb;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .warn{background:#fff4e5;border:1px solid #ffd08a;padding:8px;border-radius:6px;color:#5a3e00;margin-top:10px}
  .outwrap{margin-top:12px}
  .outbox{width:100%;min-height:160px;padding:10px;border-radius:6px;border:1px solid #ccc;background:#fcfdff;white-space:pre-wrap;font-family:monospace}
  .row{display:flex;gap:8px;align-items:center}
  .copybtn{display:inline-flex;align-items:center;gap:6px}
  .small{font-size:13px;color:var(--muted)}
  .advanced{margin-top:8px;border-top:1px dashed #e6e9f2;padding-top:10px}
</style>
</head>
<body>
<h2>Match TSV Generator â€” BO / TB aware</h2>
<p class="small">Paste match data (left) or upload a .txt file (right). Configure Protects, Bans and BO; click <b>Generate</b>. FF matches are skipped entirely.</p>

<div class="wrap">
  <div class="pane">
    <h4>Paste raw match text</h4>
    <textarea id="inputText" placeholder="Paste match blocks here (one or many)"></textarea>
  </div>

  <div class="divider"></div>

  <div class="pane">
    <h4>Upload .txt</h4>
    <input id="fileInput" type="file" accept=".txt,text/plain" />
    <div class="small" style="margin-top:8px">File is read as plain text client-side only. No upload to server.</div>

    <div class="controls" style="margin-top:12px;flex-direction:column;align-items:flex-start">
      <div class="row">
        <label>Protects:
          <input id="protectCount" type="number" value="4" min="0" max="8" />
        </label>
        <label>Bans:
          <input id="banCount" type="number" value="4" min="0" max="8" />
        </label>
        <label>BO:
          <input id="boCount" type="number" value="9" min="1" max="99" />
        </label>
      </div>

      <div class="row" style="margin-top:6px">
        <label><input id="forceTB" type="checkbox"> Force TB1</label>
        <label><input id="autoTB" type="checkbox" checked> Auto-detect TB from Score & BO</label>
        <label><input id="strictValidate" type="checkbox" checked> Validate picks (AA1)</label>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="generateBtn">Generate TSV</button>
        <button id="previewBtn" title="Show parsed rows in a readable table">Preview</button>
      </div>

      <div style="margin-top:10px">
        <label><input id="advancedToggle" type="checkbox"> Advanced settings</label>
        <div id="advancedPanel" class="advanced" style="display:none">
          <div class="small">If you want separate 'cell slot' columns (for spreadsheet alignment) that differ from Protects/Bans counts, set them here. Usually you can leave blank to match the counts above.</div>
          <div style="margin-top:6px">
            <label>Protect cell slots:
              <input id="protectSlots" type="number" value="" min="0" max="12" placeholder="default = Protects" />
            </label>
            <label>Ban cell slots:
              <input id="banSlots" type="number" value="" min="0" max="12" placeholder="default = Bans" />
            </label>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<div id="warningArea"></div>

<div class="outwrap">
  <div class="row" style="justify-content:space-between;align-items:center">
    <h4>Output (TSV for Google Sheets)</h4>
    <div>
      <button id="copyBtn" class="copybtn" title="Copy to clipboard">ðŸ“‹ Copy</button>
    </div>
  </div>
  <div id="output" class="outbox" contenteditable="false"></div>
</div>

<script>
/* ---------- Utilities ---------- */
const keywords = ['Round of','Quarterfinals','Semifinals','Finals','Grand Finals','Grandfinals','GF','QF','SF'];

function uppercaseToken(s){ return String(s||'').trim().toUpperCase(); }
function splitTokens(s){
  if(!s) return [];
  return s.split(/[\|\t,;]+/).map(uppercaseToken).filter(Boolean);
}
function safeText(s){ return String(s===null||s===undefined?'':s); }

/* ---------- Extraction helpers ---------- */
function extractMPID(block){
  const m1 = block.match(/MP ID\s*[:\s]*([0-9]{4,12})/i);
  if(m1) return m1[1];
  // fallback: any 6+ digit number that looks like an ID
  const m2 = block.match(/\b([0-9]{6,12})\b/);
  return m2 ? m2[1] : '';
}

function extractSectionLines(block, key){
  // match lines under a header like "Bans" until next header word or end
  const pattern = new RegExp('^\\s*' + key + '\\s*[\\r\\n]+([\\s\\S]*?)(?=\\n\\s*\\w+\\s|\\n\\s*\\w+:|$)', 'im');
  const m = block.match(pattern);
  if(m) return m[1].trim();
  // single-line fallback: "Bans ...\n"
  const single = block.match(new RegExp(key + '\\s*[:\\s]*([\\|\\w\\d,\\s-]*)', 'i'));
  return single ? single[1].trim() : '';
}

function extractScore(block){
  // Find Score then two numbers OR "FF"
  const scorePattern = /Score\s*[:\s]*([\d]+)\s*[\r\n]+\s*([\d]+)|Score\s*[:\s]*([0-9]+)\s*[:]\s*([0-9]+)|Score\s*[:\s]*([0-9]+)\s*-\s*([0-9]+)/i;
  const m = block.match(scorePattern);
  if(m){
    // pick first two numeric groups that exist
    const nums = m.slice(1).filter(v=>v && /^\d+$/.test(v)).slice(0,2).map(Number);
    if(nums.length===2) return nums;
  }
  // fallback: find two numbers near each other on separate lines after 'Score' word
  const idx = block.search(/Score/i);
  if(idx>=0){
    const tail = block.slice(idx, idx+100);
    const numMatches = tail.match(/\d+/g);
    if(numMatches && numMatches.length>=2) return [Number(numMatches[0]), Number(numMatches[1])];
  }
  return null;
}

function hasFF(block){
  // Score contains FF (some inputs show "Score\n0\nFF")
  return /\bFF\b/i.test(block) && /Score/i.test(block);
}

function findRoundKeywords(text){
  const found = new Set();
  for(const k of keywords){
    if(new RegExp('\\b' + k.replace(/\s+/g,'\\s+') + '\\b','i').test(text)) found.add(k);
  }
  return Array.from(found);
}

/* ---------- Parse single block ---------- */
function parseMatchBlock(block){
  if(!block || !block.trim()) return null;
  // Skip FF entirely
  if(hasFF(block)) return null;
  const mpid = extractMPID(block);
  if(!mpid) return null; // skip if no mpid found
  // Extract sections
  const protectsRaw = extractSectionLines(block,'Protects') || '';
  const bansRaw = extractSectionLines(block,'Bans') || '';
  let picksRaw = extractSectionLines(block,'Picks') || '';
  // If picks empty, attempt to extract lines with '|' or tokens
  if(!picksRaw){
    const lines = block.split(/[\r\n]+/).map(l=>l.trim()).filter(Boolean);
    const pickLines = lines.filter(l=> l.includes('|') || /[A-Za-z]{2,}\d/.test(l));
    if(pickLines.length) picksRaw = pickLines.join('|');
  }
  const protects = splitTokens(protectsRaw);
  const bans = splitTokens(bansRaw);
  // picks may be multi-line: join lines then split
  const picksLines = picksRaw.split(/[\r\n]+/).map(l=>l.trim()).filter(Boolean);
  let picks = [];
  for(const pl of picksLines) picks = picks.concat(splitTokens(pl));
  // extract score (for TB auto-detection)
  const score = extractScore(block); // returns [a,b] or null
  return { mpid, protects, bans, picks, score, raw:block };
}

/* ---------- Row formatting ---------- */
function formatRow(match, protectSlots, banSlots, forceTB, autoTB, bo, strictValidate){
  const out = [match.mpid];
  // write protect slots
  for(let i=0;i<protectSlots;i++) out.push(match.protects[i] || '');
  // bans
  for(let i=0;i<banSlots;i++) out.push(match.bans[i] || '');

  // picks normalize & optionally validate
  let picks = match.picks.map(uppercaseToken);
  // auto TB detection from score + BO
  if(autoTB && match.score && bo && bo>0){
    const a = match.score[0], b = match.score[1];
    const mx = Math.max(a,b), mn = Math.min(a,b);
    const winThreshold = Math.ceil(bo/2);
    // user rule: TB if max == winThreshold && min == winThreshold-1  OR max > winThreshold
    if((mx === winThreshold && mn === winThreshold - 1) || mx > winThreshold){
      if(!picks.some(p => /^TB\d+/i.test(p))) picks.push('TB1');
    }
  }
  // force TB
  if(forceTB && !picks.some(p => /^TB\d+/i.test(p))) picks.push('TB1');

  // strict validation (AA1)
  if(strictValidate){
    picks = picks.map(tok=>{
      const t = uppercaseToken(tok);
      if(!t) return '';
      if(/^TB\d+$/i.test(t)) return t;
      // allow 2+ letters followed by 1-2 digits (rare 2-digit)
      if(/^[A-Z]{2,}\d{1,2}$/.test(t)) return t;
      // sanitize fallback
      const filtered = t.replace(/[^A-Z0-9]/g,'');
      return filtered;
    }).filter(Boolean);
  }
  out.push(...picks);
  return out.join('\t');
}

/* ---------- Main UI logic ---------- */

const generateBtn = document.getElementById('generateBtn');
const copyBtn = document.getElementById('copyBtn');
const previewBtn = document.getElementById('previewBtn');
const warningArea = document.getElementById('warningArea');

function updateWarning(text){ warningArea.innerHTML = text ? '<div class="warn">'+text+'</div>' : ''; }

function splitIntoBlocks(txt){
  // try to split by round headers first (keeps header lines)
  const re = /(?=(?:\bRound of\b|\bQuarterfinals\b|\bSemifinals\b|\bFinals\b|\bGrand Finals\b|\bGrandfinals\b|\bQF\b|\bSF\b))/ig;
  const parts = txt.split(re).map(s=>s.trim()).filter(Boolean);
  // if this produced 1 and the text seems long, fallback to double-newline split
  if(parts.length === 1){
    const alt = txt.split(/[\r\n]{2,}/).map(s=>s.trim()).filter(Boolean);
    return alt.length ? alt : parts;
  }
  return parts;
}

generateBtn.addEventListener('click', () => {
  const txt = document.getElementById('inputText').value || '';
  const protectCount = Math.max(0, Math.min(12, parseInt(document.getElementById('protectCount').value||4,10)));
  const banCount = Math.max(0, Math.min(12, parseInt(document.getElementById('banCount').value||4,10)));
  const bo = Math.max(1, parseInt(document.getElementById('boCount').value||9,10));
  const forceTB = document.getElementById('forceTB').checked;
  const autoTB = document.getElementById('autoTB').checked;
  const strictValidate = document.getElementById('strictValidate').checked;

  // advanced slots override if present
  const advProtect = document.getElementById('protectSlots').value;
  const advBan = document.getElementById('banSlots').value;
  const protectSlots = advProtect ? Math.max(0,Math.min(12,parseInt(advProtect,10))) : protectCount;
  const banSlots = advBan ? Math.max(0,Math.min(12,parseInt(advBan,10))) : banCount;

  // split into blocks
  const blocks = splitIntoBlocks(txt);
  // detect distinct round types in the whole text
  const foundRounds = findRoundKeywords(txt);
  updateWarning(foundRounds.length > 1 ? 'Warning: multiple round types detected in this input â€” make sure you intended to parse several rounds at once.' : '');

  const rows = [];
  for(const b of blocks){
    const parsed = parseMatchBlock(b);
    if(!parsed) continue; // skip FF or unmatched
    const row = formatRow(parsed, protectSlots, banSlots, forceTB, autoTB, bo, strictValidate);
    rows.push(row);
  }
  document.getElementById('output').textContent = rows.join('\n') || '(no matches parsed)';
});

copyBtn.addEventListener('click', async () => {
  const out = document.getElementById('output').textContent;
  if(!out || out.startsWith('(no matches')) return alert('Nothing to copy');
  try {
    await navigator.clipboard.writeText(out);
    alert('Copied TSV to clipboard â€” paste into Google Sheets (first cell).');
  } catch(e){ alert('Copy failed: ' + e); }
});

/* preview: show parsed rows in readable format (small) */
previewBtn.addEventListener('click', () => {
  const txt = document.getElementById('inputText').value || '';
  const blocks = splitIntoBlocks(txt);
  const rows = [];
  for(const b of blocks){
    const parsed = parseMatchBlock(b);
    if(!parsed) rows.push('(skipped: FF or no MP ID)'); else {
      rows.push(`MP:${parsed.mpid}  Score:${parsed.score?parsed.score.join('-'):'?'}  Protects:${parsed.protects.join(',')||'-'}  Bans:${parsed.bans.join(',')||'-'}  Picks:${parsed.picks.join(',')||'-'}`);
    }
  }
  alert(rows.join('\\n\\n'));
});

/* file upload handler (client only) */
document.getElementById('fileInput').addEventListener('change', (ev) => {
  const f = ev.target.files[0];
  if(!f) return;
  if(!f.type.includes('text') && !f.name.endsWith('.txt')) {
    alert('Please upload a .txt file.');
    return;
  }
  const fr = new FileReader();
  fr.onload = () => { document.getElementById('inputText').value = fr.result; };
  fr.readAsText(f);
});

/* advanced toggle */
document.getElementById('advancedToggle').addEventListener('change', (e)=>{
  document.getElementById('advancedPanel').style.display = e.target.checked ? 'block' : 'none';
});
</script>
</body>
</html>