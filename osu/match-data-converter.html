<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Match TSV Generator</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:20px;background:#f7f8fb;color:#111}
  .wrap{display:flex;gap:18px;align-items:flex-start}
  .pane{flex:1;background:#fff;border:1px solid #e2e6ef;padding:12px;border-radius:8px;min-width:260px;box-shadow:0 1px 4px rgba(0,0,0,.04)}
  textarea{width:100%;min-height:260px;font-family:monospace;padding:8px;border-radius:6px;border:1px solid #ddd}
  .divider{width:2px;background:linear-gradient(#e6e9f2,#e6e9f2);border-radius:2px}
  label{display:inline-block;margin-right:10px}
  .controls{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{background:#1f6feb;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .outwrap{margin-top:12px}
  .outbox{width:100%;min-height:140px;padding:10px;border-radius:6px;border:1px solid #ccc;background:#fcfdff;white-space:pre-wrap;font-family:monospace}
  .small{font-size:13px;color:#555}
  .warn{background:#fff4e5;border:1px solid #ffd08a;padding:8px;border-radius:6px;color:#5a3e00;margin-top:10px}
  .row{display:flex;gap:8px;align-items:center}
  .copybtn{display:inline-flex;align-items:center;gap:6px}
  .icon{font-size:16px}
</style>
</head>
<body>
<h2>Match TSV Generator</h2>
<p class="small">Paste raw match blocks into the left box or upload a .txt file on the right. Configure Protect/Ban slots then press <b>Generate</b>. FF matches are skipped.</p>

<div class="wrap">
  <div class="pane">
    <h4>Paste match data</h4>
    <textarea id="inputText" placeholder="Paste match text here (one or multiple matches)"></textarea>
  </div>

  <div style="display:flex;flex-direction:column;align-items:center;gap:12px">
    <div class="divider" style="height:320px"></div>
    <div class="small">or</div>
  </div>

  <div class="pane">
    <h4>Upload .txt file</h4>
    <input id="fileInput" type="file" accept=".txt,text/plain" />
    <div class="small" style="margin-top:8px">File is read as plain text client-side only. No data sent to server.</div>
  </div>
</div>

<div style="margin-top:12px" class="controls">
  <label>Protect slots: <input type="number" id="protectSlots" value="4" min="0" max="8" /></label>
  <label>Ban slots: <input type="number" id="banSlots" value="4" min="0" max="8" /></label>
  <label><input id="forceTB" type="checkbox"> Force TB1 (append)</label>
  <label><input id="strictValidate" type="checkbox" checked> Validate pick format (AA1)</label>
  <button id="generateBtn">Generate TSV</button>
</div>

<div id="warningArea"></div>

<div class="outwrap">
  <div class="row" style="justify-content:space-between;align-items:center">
    <h4>Output (TSV for Google Sheets)</h4>
    <div>
      <button id="copyBtn" class="copybtn" title="Copy to clipboard">ðŸ“‹ Copy</button>
    </div>
  </div>
  <div id="output" class="outbox" contenteditable="false"></div>
</div>

<script>
/* === Utilities === */
function safeText(s){ return String(s === null || s === undefined ? '' : s); }
function uppercaseToken(tok){ return tok.trim().toUpperCase(); }

function splitTokens(s){
  if(!s) return [];
  // common separators: | , whitespace ; ignore empty chunks
  return s.split(/[\|\t,;]+/).map(t=>uppercaseToken(t)).filter(Boolean);
}

// detect FF: line "Score" followed by "FF" or standalone "FF" in block
function isFF(block){
  return /\bFF\b/i.test(block) && /\bScore\b/i.test(block);
}

// find MP ID numeric
function extractMPID(block){
  // try common patterns
  const m1 = block.match(/MP ID\s*[\r\n\s]*([0-9]{4,})/i);
  if(m1) return m1[1];
  const m2 = block.match(/MP ID[:\s]*([0-9]{4,})/i);
  if(m2) return m2[1];
  const m3 = block.match(/\b([0-9]{6,12})\b/); // fallback: any long number
  return m3 ? m3[1] : '';
}

// extract section lines after keyword
function extractSection(block, key){
  const re = new RegExp(key + '\\s*([\\s\\S]*?)(?:\\n\\s*\\w+\\s|$)', 'i');
  const m = block.match(re);
  if(!m) return '';
  return m[1].trim();
}

// fallback section extraction (search line starting with key)
function extractSectionLines(block, key){
  const pattern = new RegExp('^\\s*' + key + '\\s*\\n([\\s\\S]*?)(?=\\n\\s*\\w+:|\\n\\s*\\w+\\s|$)', 'im');
  const m = block.match(pattern);
  if(m) return m[1].trim();
  // fallback: try single-line "Bans ...\n"
  const ml = block.match(new RegExp(key + '\\s*([\\|\\w\\d,\\s-]*)', 'i'));
  return ml ? ml[1].trim() : '';
}

function findAllRoundKeywords(text){
  const keywords = ['Round of','Quarterfinals','Semifinals','Finals','Grand Finals','Grandfinals','GF','QF','SF'];
  const found = new Set();
  for(const k of keywords){
    if(new RegExp(k, 'i').test(text)) found.add(k.toLowerCase());
  }
  return Array.from(found);
}

/* === Parser for a block of text representing one match === */
function parseMatchBlock(block){
  // Skip empty
  if(!block || !block.trim()) return null;
  // If FF -> skip entirely (return null marker)
  if(isFF(block)) return null;
  const mpid = extractMPID(block);
  if(!mpid) {
    // if no mpid and not FF, still skip (we assume MPID required)
    return null;
  }
  // Extract protects/bans/picks (robust)
  let protectsRaw = extractSectionLines(block, 'Protects') || extractSection(block, 'Protects') || '';
  let bansRaw = extractSectionLines(block, 'Bans') || extractSection(block, 'Bans') || '';
  let picksRaw = extractSectionLines(block, 'Picks') || extractSection(block, 'Picks') || '';

  // If picksRaw empty, try to find lines starting with tokens (fallback)
  if(!picksRaw){
    // attempt to pick up lines of tokens (lines containing |)
    const lines = block.split('\\n').map(l=>l.trim()).filter(Boolean);
    const candidates = [];
    for(const l of lines){
      if(/[A-Za-z]{2,}\d/.test(l) || l.indexOf('|')>=0) candidates.push(l);
    }
    if(candidates.length){
      picksRaw = candidates.join('|');
    }
  }

  const protects = splitTokens(protectsRaw);
  const bans = splitTokens(bansRaw);
  // picks may be multi-line (teamA picks line then teamB picks line). split on newlines then flatten by separators
  const picksLines = picksRaw.split(/[\r\n]+/).map(s=>s.trim()).filter(Boolean);
  let picks = [];
  for(const pl of picksLines){
    picks = picks.concat(splitTokens(pl));
  }

  return { mpid, protects, bans, picks, raw:block };
}

/* === Format a single match row (TSV string) === */
function formatRow(match, protectSlots, banSlots, forceTB, strictValidate){
  // Fill protects to protectSlots
  const out = [match.mpid];
  for(let i=0;i<protectSlots;i++) out.push(match.protects[i] || '');

  for(let i=0;i<banSlots;i++) out.push(match.bans[i] || '');

  // normalize picks
  let picks = match.picks.map(p => uppercaseToken(p));
  // append TB1 if forced and not present
  if(forceTB && !picks.some(p => /^TB\d+/i.test(p))) picks.push('TB1');

  // validate picks tokens if requested
  if(strictValidate){
    picks = picks.map(tok=>{
      const t = tok.trim().toUpperCase();
      if(!t) return '';
      if(/^TB\d+$/i.test(t)) return t;
      // allow 2+ letters + 1-2 digits
      if(/^[A-Z]{2,}\d{1,2}$/.test(t)) return t;
      // fallback: sanitize (remove bad chars)
      const filtered = t.replace(/[^A-Z0-9]/g,'');
      return filtered;
    }).filter(Boolean);
  }

  // append picks
  out.push(...picks);
  return out.join('\\t');
}

/* === Top-level generate function === */
document.getElementById('generateBtn').addEventListener('click', () => {
  const txt = document.getElementById('inputText').value || '';
  const protectSlots = Math.max(0, Math.min(8, parseInt(document.getElementById('protectSlots').value||4,10)));
  const banSlots = Math.max(0, Math.min(8, parseInt(document.getElementById('banSlots').value||4,10)));
  const forceTB = document.getElementById('forceTB').checked;
  const strictValidate = document.getElementById('strictValidate').checked;

  // split input into blocks: use headers (Round, Quarterfinals, Semifinals, Finals, Grand Finals) or double newlines
  let blocks = txt.split(/(?=\\b(Round of|Quarterfinals|Semifinals|Finals|Grand Finals|Grandfinals)\\b)/i).filter(Boolean);
  // fallback: split by two or more newlines
  if(blocks.length === 0) blocks = txt.split(/\\n{2,}/).map(s=>s.trim()).filter(Boolean);
  if(blocks.length === 0){
    document.getElementById('output').textContent = '';
    return;
  }

  // detect multiple different round keywords
  const roundsFound = findAllRoundKeywords(txt);
  const warningArea = document.getElementById('warningArea');
  warningArea.innerHTML = '';
  if(roundsFound.length > 1){
    const w = document.createElement('div'); w.className='warn';
    w.textContent = 'Warning: multiple round types detected in this input â€” make sure you intended to parse several rounds at once.';
    warningArea.appendChild(w);
  }

  const rows = [];
  for(const b of blocks){
    const parsed = parseMatchBlock(b);
    if(!parsed) continue; // skip FF or unmatched blocks
    const row = formatRow(parsed, protectSlots, banSlots, forceTB, strictValidate);
    rows.push(row);
  }

  const outputStr = rows.join('\\n');
  document.getElementById('output').textContent = outputStr || '(no matches parsed)';
});

/* === Copy button === */
document.getElementById('copyBtn').addEventListener('click', async () => {
  const out = document.getElementById('output').textContent;
  if(!out || out.startsWith('(no matches')) return alert('Nothing to copy');
  try{
    await navigator.clipboard.writeText(out);
    alert('Copied TSV to clipboard â€” paste into Google Sheets (first cell).');
  }catch(e){
    alert('Copy failed: ' + e);
  }
});

/* === File upload handler (client-side only) === */
document.getElementById('fileInput').addEventListener('change', (ev) => {
  const f = ev.target.files[0];
  if(!f) return;
  if(!f.type.includes('text') && !f.name.endsWith('.txt')) {
    alert('Please upload a .txt file.');
    return;
  }
  const fr = new FileReader();
  fr.onload = () => {
    // write safely into textarea (text only)
    document.getElementById('inputText').value = fr.result;
  };
  fr.readAsText(f);
});
</script>
</body>
</html>